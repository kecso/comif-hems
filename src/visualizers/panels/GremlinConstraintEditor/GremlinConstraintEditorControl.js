/*globals define, WebGMEGlobal*/
/**
 * Generated by VisualizerGenerator 1.7.0 from webgme on Tue Jun 26 2018 09:35:00 GMT-0500 (Central Daylight Time).
 */

define([
    'q',
    'js/Constants',
    'js/Loader/LoaderCircles',
    'text!comif-hems/domain.txt',
    'comif-hems/clientUtils'
], function (Q,
             CONSTANTS,
             LoaderCircle,
             domainTxt,
             utils) {

    'use strict';

    var GremlinConstraintEditorControl;

    GremlinConstraintEditorControl = function (options) {
        var self = this;

        this._logger = options.logger.fork('Control');

        this._client = options.client;

        this._widget = options.widget;
        this._currentNodeId = null;
        this._gatheringSegments = false;
        this._missedEvents = false;

        this._territory = null;
        this._segmentInfo = {};
        this._UID = this._client.addUI(self, function (events) {
            self._eventCallback(events);
        });

        this._initWidgetEventHandlers();

        this._loader = new LoaderCircle({containerElement: this._widget._el});
        this._loader.setSize(100);
        this._logger.debug('ctor finished');
    };

    GremlinConstraintEditorControl.prototype._initWidgetEventHandlers = function () {
        var self = this;
        this._widget.onSave = function (segmentedDocumentObject) {
            // console.log(segmentedDocumentObject);
            self._SaveDocument(segmentedDocumentObject);
        };
    };

    /* * * * * * * * Visualizer content update callbacks * * * * * * * */
    // One major concept here is with managing the territory. The territory
    // defines the parts of the project that the visualizer is interested in
    // (this allows the browser to then only load those relevant parts).
    GremlinConstraintEditorControl.prototype.selectedObjectChanged = function (nodeId) {
        var node = this._client.getNode(nodeId);

        if (node) {
            //we have a viable component type so let us change things
            this._currentNodeId = nodeId;
            this._selfPatterns = {};
            this._selfPatterns[nodeId] = {children: -1};
            this._client.updateTerritory(this._UID, this._selfPatterns);
        } else {
            this._logger.info('received unwanted object change event');
        }
    };

    /* * * * * * * * Node Event Handling * * * * * * * */
    GremlinConstraintEditorControl.prototype._eventCallback = function (events) {
        var self = this,
            i = events ? events.length : 0,
            event;

        this._logger.debug('_eventCallback \'' + i + '\' items');

        this._buildSegmentInfo(this._currentNodeId)
            .then(function (segmentedDocument) {
                self._widget.setSegmentedDocument(segmentedDocument);
            })
            .catch(function (err) {
                self._logger.error(err);
            })
        this._logger.debug('_eventCallback \'' + events.length + '\' items - DONE');
    };

    GremlinConstraintEditorControl.prototype._stateActiveObjectChanged = function (model, activeObjectId) {
        if (this._currentNodeId === activeObjectId) {
            // The same node selected as before - do not trigger
        } else {
            this.selectedObjectChanged(activeObjectId);
        }
    };

    /* * * * * * * * Segmented Document Handling * * * * * * * */
    GremlinConstraintEditorControl.prototype._getSegmentOffset = function (segmentedDocument, segmentId) {
        var compiledText = '',
            index = 0,
            sId = segmentedDocument.composition[0] || null;

        while (sId !== null && sId !== segmentId && index < segmentedDocument.composition.length) {
            compiledText += segmentedDocument.segments[sId].value + '\n';
            sId = segmentedDocument.composition[++index];
        }

        return compiledText.split('\n').length;
    };

    GremlinConstraintEditorControl.prototype._buildSegmentInfo = function (nodeId) {
        var self = this,
            node = self._client.getNode(nodeId),
            deferred = Q.defer(),
            segmentedDocument = {
                composition: [],
                segments: {},
                errors: []
            };

        if (node === null) {
            deferred.resolve(segmentedDocument);
            return deferred.promise;
        }

        self._client.getCoreInstance({}, function (err, coreInstance) {
            if (err) {
                deferred.reject(err);
                return;
            }

            utils.getGremlinData(coreInstance.core, coreInstance.rootNode, nodeId, node.getAttribute('name'),
                function (err, gremlin) {
                    if (err) {
                        deferred.reject(err);
                        return;
                    }

                    segmentedDocument.composition = ['fixed', 'user'];
                    segmentedDocument.segments.fixed = {
                        value: gremlin,
                        options: {readonly: true}
                    };

                    segmentedDocument.segments.user = {
                        value: self._client.getNode(self._currentNodeId).getAttribute('_gremlin_constraints') || '',
                        options: {readonly: false}
                    };

                    deferred.resolve(segmentedDocument);

                });

        });

        return deferred.promise;
    };

    GremlinConstraintEditorControl.prototype._SaveDocument = function (changedSegments) {
        if (changedSegments.hasOwnProperty('user')) {
            this._client.setAttribute(this._currentNodeId, '_gremlin_constraints', changedSegments.user);
        }
    };

    GremlinConstraintEditorControl.prototype._checkConformance = function () {
        var self = this,
            context;

        self._loader.start();
        context = self._client.getCurrentPluginContext('GremlinConformanceCheck');
        context.pluginConfig = {formulaProjectFile: self._widget.getDocument()};
        self._client.runServerPlugin('GremlinConformanceCheck', context, function (err, pluginResult) {
            self._loader.stop();
            if (err) {
                self._client.notifyUser({message: 'Conformance checking failed: ' + err, severity: 'error'});
            } else if (pluginResult.success) {
                self._client.notifyUser('Your model is well-formed!');
            } else {
                self._client.notifyUser('Your model is non conformant!');
            }
        });
    };
    /* * * * * * * * Visualizer life cycle callbacks * * * * * * * */
    GremlinConstraintEditorControl.prototype.destroy = function () {
        this._detachClientEventListeners();
        this._removeToolbarItems();
    };

    GremlinConstraintEditorControl.prototype._attachClientEventListeners = function () {
        this._detachClientEventListeners();
        WebGMEGlobal.State.on('change:' + CONSTANTS.STATE_ACTIVE_OBJECT, this._stateActiveObjectChanged, this);
    };

    GremlinConstraintEditorControl.prototype._detachClientEventListeners = function () {
        WebGMEGlobal.State.off('change:' + CONSTANTS.STATE_ACTIVE_OBJECT, this._stateActiveObjectChanged);
    };

    GremlinConstraintEditorControl.prototype.onActivate = function () {
        this._attachClientEventListeners();
        this._displayToolbarItems();

        if (typeof this._currentNodeId === 'string') {
            WebGMEGlobal.State.registerActiveObject(this._currentNodeId, {suppressVisualizerFromNode: true});
        }
    };

    GremlinConstraintEditorControl.prototype.onDeactivate = function () {
        this._detachClientEventListeners();
        this._hideToolbarItems();
    };

    /* * * * * * * * * * Updating the toolbar * * * * * * * * * */
    GremlinConstraintEditorControl.prototype._displayToolbarItems = function () {

        if (this._toolbarInitialized === true) {
            for (var i = this._toolbarItems.length; i--;) {
                this._toolbarItems[i].show();
            }
        } else {
            this._initializeToolbar();
        }
    };

    GremlinConstraintEditorControl.prototype._hideToolbarItems = function () {

        if (this._toolbarInitialized === true) {
            for (var i = this._toolbarItems.length; i--;) {
                this._toolbarItems[i].hide();
            }
        }
    };

    GremlinConstraintEditorControl.prototype._removeToolbarItems = function () {

        if (this._toolbarInitialized === true) {
            for (var i = this._toolbarItems.length; i--;) {
                this._toolbarItems[i].destroy();
            }
        }
    };

    GremlinConstraintEditorControl.prototype._initializeToolbar = function () {
        var self = this,
            toolBar = WebGMEGlobal.Toolbar;

        this._toolbarItems = [];

        this._toolbarItems.push(toolBar.addSeparator());

        this.$btnSave = toolBar.addButton({
            title: 'Save changes',
            icon: 'glyphicon glyphicon-floppy-disk',
            clickFn: function (/*data*/) {
                self._SaveDocument(self._widget.getChangedSegments());
            }
        });
        this._toolbarItems.push(this.$btnSave);

        this.$btnCheck = toolBar.addButton({
            title: 'Check model conformance',
            icon: 'glyphicon glyphicon-eye-open',
            clickFn: function (/*data*/) {
                self._checkConformance();
            }
        });
        this._toolbarItems.push(this.$btnCheck);

        this._toolbarInitialized = true;
    };

    return GremlinConstraintEditorControl;
});
